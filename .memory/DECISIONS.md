# Решения

## Проект: ai-svetlio

## Формат
Всяко решение се записва така:

### [Дата] Заглавие на решението
**Контекст:** Защо беше нужно това решение
**Решение:** Какво избрахме
**Алтернативи:** Какво друго разгледахме
**Последствия:** Какво следва от решението

---

## Решения

### 2026-02-01 Избор на AI_Svetlio
**Контекст:** Нужда от система за памет и управление на проекти с AI
**Решение:** Използваме AI_Svetlio за .memory/ система
**Алтернативи:** Ръчна документация, други системи
**Последствия:** AI агентите ще имат достъп до контекст между сесии

---

### 2026-02-03 Създаване на Iron Rules документация
**Контекст:** При реална употреба на AI_Svetlio в други проекти беше установено, че AI агентите: "забравят" контекста при дълги чатове, редактират код "на парче" без да четат целия файл, не правят backup преди промени, гадаят пътища вместо да четат документация.
**Решение:** Създадени са 3 документа: IRON_RULES.md (11 задължителни правила), REFRESH_REMINDER.md (кратко напомняне за Context Refresh), USER_GUIDE.md (наръчник за потребителя)
**Алтернативи:** Вграждане директно в кода (отхвърлено - твърде сложно за v1.x), чакане на v2.0 (отхвърлено - проблемът е реален сега)
**Последствия:** Документацията е готова за интеграция в CLAUDE.md шаблона в v1.1.0+

---

### 2026-02-03 Стратегия за версиониране
**Контекст:** Потребителят иска да може да избира между версии при инсталация, без да се губят старите версии.
**Решение:** npm поддържа версиониране автоматично - v1.0.0 остава непроменена, нови функции влизат в v1.1.0+, breaking changes влизат в v2.0.0
**Алтернативи:** Отделни npm пакети за всяка версия (отхвърлено - npm вече поддържа това)
**Последствия:** Потребителите избират версия с `npm install ai-svetlio@версия`

---

### 2026-02-03 Универсални правила за всички IDE
**Контекст:** Потребителят иска максимално прост и универсален инструмент. Без значение кой агент/IDE се ползва (Claude Code, Cursor, Antigravity), правилата трябва да са едни и същи.
**Решение:** Iron Rules се вграждат в шаблоните за CLAUDE.md, .cursorrules, .antigravity/rules.md. При `svetlio init` всички получават идентични правила.
**Алтернативи:** Поддръжка на Gemini CLI, GPT Context и др. (отхвърлено - фокус върху основните 3 IDE)
**Последствия:** v1.1.0 ще включва Iron Rules във всички шаблони. Потребителят не мисли за агента — просто работи.

---

### 2026-02-08 Секция "Споделена отговорност" — задача #1
**Контекст:** Паметта на Светльо се записва от AI агента, но агентът не контролира кога потребителят затваря чата. Ако потребителят затвори преди агентът да запише в `.memory/` — паметта остава неактуална. Това е фундаментално технологично ограничение на всички AI агенти — те не могат да пишат след като сесията е прекратена.
**Решение:** Добавяне на ясна, кратка секция "⚠️ Споделена отговорност" в README.md, USER_GUIDE.md и генерираните шаблони. Текстът обяснява, че потребителят трябва да изчака потвърждение от агента, че паметта е записана, преди да затвори сесията. Това е приоритет #1, преди всички нови функции.
**Алтернативи:** (1) Да не се споменава (отхвърлено — потребителите ще се сблъскат с проблема и ще обвинят инструмента), (2) Автоматичен save при всяко съобщение (отхвърлено — технически невъзможно, агентът решава кога да пише)
**Последствия:** Потребителите ще знаят от самото начало, че трябва да приключват сесиите правилно. Командата `svetlio end` (v1.4.0) ще помогне за формализирането на този процес.

---

### 2026-02-09 Web Viewer — вграден HTTP сървър (v1.4.0)
**Контекст:** Потребителите искат визуален преглед на .memory/ файловете без да ползват CLI или IDE. Нужен е лесен начин да видиш състоянието на проекта в браузъра — read-only, без риск от промени.
**Решение:** Вграден HTTP сървър с Node.js `http` модул (0 нови зависимости). `svetlio web` стартира localhost:3847, отваря браузър, показва всички .memory/ файлове с markdown rendering и auto-refresh на 5 сек. Плюс "един клик" стартиране: `open-memory.bat/.sh` се генерира при `svetlio init`, а `svetlio shortcut` създава desktop shortcut.
**Алтернативи:** (1) Express — отхвърлено, overkill за 1 read-only страница и добавя зависимост; (2) Генериран HTML файл без сървър — отхвърлено, няма live updates; (3) Fastify — отхвърлено, нова зависимост без нужда.
**Последствия:** Потребителите могат да виждат .memory/ визуално без CLI познания. Launcher файлът позволява двоен клик стартиране.

---

### 2026-02-08 Вградени еднодумни workflow команди (v1.4.0)
**Контекст:** Текущите команди (`init`, `onboard`, `repair`) са технически. Потребителят мисли в terms на workflow: "започвам", "продължавам", "приключвам". Нужни са прости, интуитивни команди с по една дума.
**Решение:** 4 нови команди — `старт/start`, `вкарай/import`, `продължи/continue`, `край/end`. Двуезични (БГ + EN). Обвиват съществуващата логика (init, onboard, status) с по-добър UX — шаблони за чата, summary, автоматично обновяване на .memory/.
**Алтернативи:** (1) Само EN имена (отхвърлено — проектът е двуезичен), (2) Многодумни команди като `svetlio start-project` (отхвърлено — идеята е простота с една дума), (3) Интерактивен wizard за всичко (отхвърлено — командите трябва да са бързи)
**Последствия:** v1.4.0 ще предложи прост workflow: `start → continue → end`. Старите команди (`init`, `onboard`) остават за обратна съвместимост.

---

### 2026-02-13 ClientRequests система — Архитектура и разположение

**Контекст:** Клиентски заявки идват от различни канали и се губят. В CargoFlow проекта спонтанно се роди система за управление на заявки (ClientRequests) — файлово базирана, с ID-та, шаблони, регистър и Python инструменти за обработка. Системата обработи 6 заявки → 52 задачи → 17 проблема. Искаме да я вградим в ai-svetlio.

**Решение:**

1. **Разположение: `.requests/` — отделна папка до `.memory/`**
   - НЕ вътре в .memory/ — различна отговорност
   - `svetlio upgrade` НЕ пипа .requests/ (както не пипа .memory/)
   - Три защитени зони: CLAUDE.md (пипа се при upgrade), .memory/ (не се пипа), .requests/ (не се пипа)

2. **Активиране: Автоматично при `svetlio init`**
   - `svetlio init` създава И .memory/ И .requests/ наведнъж
   - Всеки проект е готов за заявки от старта
   - Няма нужда от отделна команда

3. **Inbox check: Автоматична проверка при старт/продължаваме**
   - Агентът проверява .requests/inbox/ при всяко начало на сесия
   - Ако намери файлове → докладва и чака одобрение (НЕ обработва автоматично)
   - Потребителят решава: "Да, обработи ги" или "Не, по-късно"

4. **Python bridge: Пълна поддръжка на всички формати**
   - 3 Python инструмента от CargoFlow (адаптирани): process_inbox.py, office_extractor.py, pdf_extractor.py
   - Node.js извиква Python чрез child_process
   - Graceful fallback: TXT/MD работят винаги, Python добавя EML/DOCX/PDF/MSG и др.

5. **Шаблони: Базирани на CargoFlow прототипа**
   - Всички шаблони са тествани в реален проект (doc_prototype/)
   - Адаптация: махни CargoFlow-specific, направи конфигурируемо
   - Категории и приоритети по подразбиране, но потребителят ги задава

**Алтернативи:**
- .requests/ вътре в .memory/ (отхвърлено — upgrade може да засегне, различна отговорност)
- Отделна команда `svetlio requests init` (отхвърлено — потребителят не трябва да мисли за това)
- Само TXT/MD без Python (отхвърлено — потребителят иска пълна поддръжка)
- Автоматична обработка без одобрение (отхвърлено — агентът не трябва да действа без потвърждение)

**Последствия:**
- v1.5.0 ще включва ClientRequests при `svetlio init`
- `svetlio upgrade` ще обновява правилата в CLAUDE.md (с inbox check инструкции) без да пипа .requests/
- Web Viewer ще показва .requests/ като отделна секция

---

### 2026-02-13 ClientRequests — Инвентаризация на готовите активи

**Контекст:** Преди да планираме имплементацията, трябва да знаем какво вече имаме от CargoFlow.

**Решение: Пълна инвентаризация**

**Готови шаблони (documents/):**
| Файл | Редове | Адаптация |
|------|--------|-----------|
| README.md | 282 | Махни CargoFlow, направи {project_name}. Секция 10 (SQL) → optional. Секция 11 → вградена |
| TEMPLATE.md | 70 | "Свързан договор" → "Свързана референция". "Свързан имейл ID" → "Свързан външен ID" |
| REGISTRY.md | 89 | Празна версия: само структурата без CargoFlow данни |
| TIMELINE_AND_GAP_ANALYSIS.md | 401 | Опционален шаблон за gap анализ |

**Готови Python инструменти (documents/):**
| Файл | Редове | Формати | Адаптация |
|------|--------|---------|-----------|
| process_inbox.py | 658 | EML, MSG, TXT, MD + Office bridge | Конфигурируем BASE_DIR |
| office_extractor.py | 778 | DOCX, DOC, XLSX, XLS, RTF, TXT, XML, ODT + Teams | Конфигурируем път |
| pdf_extractor.py | 608 | PDF + EML (за PDF прикачени) | Вече самостоятелен |

**Готов прототип (documents/doc_prototype/):**
- 6 реални CR файла (CR-2026-001 до CR-2026-006) — примери от различни входове
- memory_snapshot/ — показва как .memory/ и .requests/ живеят заедно
- extracted JSON файлове, body текстове, оригинални EML/DOCX
- ПРЕЗЕНТАЦИЯ_КЛИЕНТ.md — бонус шаблон

**setup_new_client.py → НЕ се включва** — CargoFlow-специфичен (PostgreSQL, Graph API)

**Липсва (трябва да се създаде):**
- requirements.txt — единен файл за Python зависимости
- Празни шаблони за нов проект (REGISTRY, inbox/README, archive/README)
- config.json — конфигурируеми категории, приоритети, default отговорник
- src/requests.ts — Node.js bridge за Python инструментите
- Web Viewer секция за .requests/

**Оценка: 80% от съдържанието е готово, 20% е адаптация + интеграция.**

---

### 2026-02-13 Ред на имплементация — svetlio upgrade → .memory/ fix → ClientRequests

**Контекст:** Имаме 3 приоритетни задачи. Трябва да определим реда, защото зависят една от друга.

**Решение:**
1. **Първо: `svetlio upgrade`** — механизмът за обновяване на правилата. Без него промените от #2 и #3 работят САМО за нови проекти.
2. **Второ: .memory/ fix** — пълен списък файлове при refresh/край. Малка промяна, влиза в upgrade шаблоните.
3. **Трето: ClientRequests** — .requests/ + Python bridge + inbox check + Web Viewer. Най-голямата промяна.

**Защо този ред:**
- upgrade трябва да е готов ПРЕДИ да променяме шаблоните (иначе старите проекти няма да получат fix-а)
- .memory/ fix е малък и бърз — влиза веднага след upgrade
- ClientRequests е голям — ползва upgrade за да доставя новите правила

**Последствия:** v1.5.0 ще включва и трите: upgrade + .memory/ fix + ClientRequests.

