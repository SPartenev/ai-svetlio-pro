# Решения

## Проект: ai-svetlio

## Формат
Всяко решение се записва така:

### [Дата] Заглавие на решението
**Контекст:** Защо беше нужно това решение
**Решение:** Какво избрахме
**Алтернативи:** Какво друго разгледахме
**Последствия:** Какво следва от решението

---

## Решения

### 2026-02-01 Избор на AI_Svetlio
**Контекст:** Нужда от система за памет и управление на проекти с AI
**Решение:** Използваме AI_Svetlio за .memory/ система
**Алтернативи:** Ръчна документация, други системи
**Последствия:** AI агентите ще имат достъп до контекст между сесии

---

### 2026-02-03 Създаване на Iron Rules документация
**Контекст:** При реална употреба на AI_Svetlio в други проекти беше установено, че AI агентите: "забравят" контекста при дълги чатове, редактират код "на парче" без да четат целия файл, не правят backup преди промени, гадаят пътища вместо да четат документация.
**Решение:** Създадени са 3 документа: IRON_RULES.md (11 задължителни правила), REFRESH_REMINDER.md (кратко напомняне за Context Refresh), USER_GUIDE.md (наръчник за потребителя)
**Алтернативи:** Вграждане директно в кода (отхвърлено - твърде сложно за v1.x), чакане на v2.0 (отхвърлено - проблемът е реален сега)
**Последствия:** Документацията е готова за интеграция в CLAUDE.md шаблона в v1.1.0+

---

### 2026-02-03 Стратегия за версиониране
**Контекст:** Потребителят иска да може да избира между версии при инсталация, без да се губят старите версии.
**Решение:** npm поддържа версиониране автоматично - v1.0.0 остава непроменена, нови функции влизат в v1.1.0+, breaking changes влизат в v2.0.0
**Алтернативи:** Отделни npm пакети за всяка версия (отхвърлено - npm вече поддържа това)
**Последствия:** Потребителите избират версия с `npm install ai-svetlio@версия`

---

### 2026-02-03 Универсални правила за всички IDE
**Контекст:** Потребителят иска максимално прост и универсален инструмент. Без значение кой агент/IDE се ползва (Claude Code, Cursor, Antigravity), правилата трябва да са едни и същи.
**Решение:** Iron Rules се вграждат в шаблоните за CLAUDE.md, .cursorrules, .antigravity/rules.md. При `svetlio init` всички получават идентични правила.
**Алтернативи:** Поддръжка на Gemini CLI, GPT Context и др. (отхвърлено - фокус върху основните 3 IDE)
**Последствия:** v1.1.0 ще включва Iron Rules във всички шаблони. Потребителят не мисли за агента — просто работи.

---

### 2026-02-08 Секция "Споделена отговорност" — задача #1
**Контекст:** Паметта на Светльо се записва от AI агента, но агентът не контролира кога потребителят затваря чата. Ако потребителят затвори преди агентът да запише в `.memory/` — паметта остава неактуална. Това е фундаментално технологично ограничение на всички AI агенти — те не могат да пишат след като сесията е прекратена.
**Решение:** Добавяне на ясна, кратка секция "⚠️ Споделена отговорност" в README.md, USER_GUIDE.md и генерираните шаблони. Текстът обяснява, че потребителят трябва да изчака потвърждение от агента, че паметта е записана, преди да затвори сесията. Това е приоритет #1, преди всички нови функции.
**Алтернативи:** (1) Да не се споменава (отхвърлено — потребителите ще се сблъскат с проблема и ще обвинят инструмента), (2) Автоматичен save при всяко съобщение (отхвърлено — технически невъзможно, агентът решава кога да пише)
**Последствия:** Потребителите ще знаят от самото начало, че трябва да приключват сесиите правилно. Командата `svetlio end` (v1.4.0) ще помогне за формализирането на този процес.

---

### 2026-02-09 Web Viewer — вграден HTTP сървър (v1.4.0)
**Контекст:** Потребителите искат визуален преглед на .memory/ файловете без да ползват CLI или IDE. Нужен е лесен начин да видиш състоянието на проекта в браузъра — read-only, без риск от промени.
**Решение:** Вграден HTTP сървър с Node.js `http` модул (0 нови зависимости). `svetlio web` стартира localhost:3847, отваря браузър, показва всички .memory/ файлове с markdown rendering и auto-refresh на 5 сек. Плюс "един клик" стартиране: `open-memory.bat/.sh` се генерира при `svetlio init`, а `svetlio shortcut` създава desktop shortcut.
**Алтернативи:** (1) Express — отхвърлено, overkill за 1 read-only страница и добавя зависимост; (2) Генериран HTML файл без сървър — отхвърлено, няма live updates; (3) Fastify — отхвърлено, нова зависимост без нужда.
**Последствия:** Потребителите могат да виждат .memory/ визуално без CLI познания. Launcher файлът позволява двоен клик стартиране.

---

### 2026-02-08 Вградени еднодумни workflow команди (v1.4.0)
**Контекст:** Текущите команди (`init`, `onboard`, `repair`) са технически. Потребителят мисли в terms на workflow: "започвам", "продължавам", "приключвам". Нужни са прости, интуитивни команди с по една дума.
**Решение:** 4 нови команди — `старт/start`, `вкарай/import`, `продължи/continue`, `край/end`. Двуезични (БГ + EN). Обвиват съществуващата логика (init, onboard, status) с по-добър UX — шаблони за чата, summary, автоматично обновяване на .memory/.
**Алтернативи:** (1) Само EN имена (отхвърлено — проектът е двуезичен), (2) Многодумни команди като `svetlio start-project` (отхвърлено — идеята е простота с една дума), (3) Интерактивен wizard за всичко (отхвърлено — командите трябва да са бързи)
**Последствия:** v1.4.0 ще предложи прост workflow: `start → continue → end`. Старите команди (`init`, `onboard`) остават за обратна съвместимост.

---

### 2026-02-13 ClientRequests система — Архитектура и разположение

**Контекст:** Клиентски заявки идват от различни канали и се губят. В CargoFlow проекта спонтанно се роди система за управление на заявки (ClientRequests) — файлово базирана, с ID-та, шаблони, регистър и Python инструменти за обработка. Системата обработи 6 заявки → 52 задачи → 17 проблема. Искаме да я вградим в ai-svetlio.

**Решение:**

1. **Разположение: `.requests/` — отделна папка до `.memory/`**
   - НЕ вътре в .memory/ — различна отговорност
   - `svetlio upgrade` НЕ пипа .requests/ (както не пипа .memory/)
   - Три защитени зони: CLAUDE.md (пипа се при upgrade), .memory/ (не се пипа), .requests/ (не се пипа)

2. **Активиране: Автоматично при `svetlio init`**
   - `svetlio init` създава И .memory/ И .requests/ наведнъж
   - Всеки проект е готов за заявки от старта
   - Няма нужда от отделна команда

3. **Inbox check: Автоматична проверка при старт/продължаваме**
   - Агентът проверява .requests/inbox/ при всяко начало на сесия
   - Ако намери файлове → докладва и чака одобрение (НЕ обработва автоматично)
   - Потребителят решава: "Да, обработи ги" или "Не, по-късно"

4. **Python bridge: Пълна поддръжка на всички формати**
   - 3 Python инструмента от CargoFlow (адаптирани): process_inbox.py, office_extractor.py, pdf_extractor.py
   - Node.js извиква Python чрез child_process
   - Graceful fallback: TXT/MD работят винаги, Python добавя EML/DOCX/PDF/MSG и др.

5. **Шаблони: Базирани на CargoFlow прототипа**
   - Всички шаблони са тествани в реален проект (doc_prototype/)
   - Адаптация: махни CargoFlow-specific, направи конфигурируемо
   - Категории и приоритети по подразбиране, но потребителят ги задава

**Алтернативи:**
- .requests/ вътре в .memory/ (отхвърлено — upgrade може да засегне, различна отговорност)
- Отделна команда `svetlio requests init` (отхвърлено — потребителят не трябва да мисли за това)
- Само TXT/MD без Python (отхвърлено — потребителят иска пълна поддръжка)
- Автоматична обработка без одобрение (отхвърлено — агентът не трябва да действа без потвърждение)

**Последствия:**
- v1.5.0 ще включва ClientRequests при `svetlio init`
- `svetlio upgrade` ще обновява правилата в CLAUDE.md (с inbox check инструкции) без да пипа .requests/
- Web Viewer ще показва .requests/ като отделна секция

---

### 2026-02-13 ClientRequests — Инвентаризация на готовите активи

**Контекст:** Преди да планираме имплементацията, трябва да знаем какво вече имаме от CargoFlow.

**Решение: Пълна инвентаризация**

**Готови шаблони (documents/):**
| Файл | Редове | Адаптация |
|------|--------|-----------|
| README.md | 282 | Махни CargoFlow, направи {project_name}. Секция 10 (SQL) → optional. Секция 11 → вградена |
| TEMPLATE.md | 70 | "Свързан договор" → "Свързана референция". "Свързан имейл ID" → "Свързан външен ID" |
| REGISTRY.md | 89 | Празна версия: само структурата без CargoFlow данни |
| TIMELINE_AND_GAP_ANALYSIS.md | 401 | Опционален шаблон за gap анализ |

**Готови Python инструменти (documents/):**
| Файл | Редове | Формати | Адаптация |
|------|--------|---------|-----------|
| process_inbox.py | 658 | EML, MSG, TXT, MD + Office bridge | Конфигурируем BASE_DIR |
| office_extractor.py | 778 | DOCX, DOC, XLSX, XLS, RTF, TXT, XML, ODT + Teams | Конфигурируем път |
| pdf_extractor.py | 608 | PDF + EML (за PDF прикачени) | Вече самостоятелен |

**Готов прототип (documents/doc_prototype/):**
- 6 реални CR файла (CR-2026-001 до CR-2026-006) — примери от различни входове
- memory_snapshot/ — показва как .memory/ и .requests/ живеят заедно
- extracted JSON файлове, body текстове, оригинални EML/DOCX
- ПРЕЗЕНТАЦИЯ_КЛИЕНТ.md — бонус шаблон

**setup_new_client.py → НЕ се включва** — CargoFlow-специфичен (PostgreSQL, Graph API)

**Липсва (трябва да се създаде):**
- requirements.txt — единен файл за Python зависимости
- Празни шаблони за нов проект (REGISTRY, inbox/README, archive/README)
- config.json — конфигурируеми категории, приоритети, default отговорник
- src/requests.ts — Node.js bridge за Python инструментите
- Web Viewer секция за .requests/

**Оценка: 80% от съдържанието е готово, 20% е адаптация + интеграция.**

---

### 2026-02-13 Deploy strategy — patch versions за малки fixes
**Контекст:** v1.5.0 имаше няколко проблема (клиентски данни в npm, липсващ CLI action, несинхронизирана документация). Трябваше бързо да ги оправим.
**Решение:** Patch versions (v1.5.1–v1.5.6) за всеки fix поотделно, вместо да чакаме и да ги пакетираме в една версия. Така всеки потребител получава fix-а веднага.
**Алтернативи:** Една голяма v1.5.1 с всички fixes (отхвърлено — забавя delivery)
**Последствия:** Повече npm versions, но по-бързи fixes. За в бъдеще: проверявай `npm pack --dry-run` и всички команди преди publish.

---

### 2026-02-13 Ред на имплементация — svetlio upgrade → .memory/ fix → ClientRequests

**Контекст:** Имаме 3 приоритетни задачи. Трябва да определим реда, защото зависят една от друга.

**Решение:**
1. **Първо: `svetlio upgrade`** — механизмът за обновяване на правилата. Без него промените от #2 и #3 работят САМО за нови проекти.
2. **Второ: .memory/ fix** — пълен списък файлове при refresh/край. Малка промяна, влиза в upgrade шаблоните.
3. **Трето: ClientRequests** — .requests/ + Python bridge + inbox check + Web Viewer. Най-голямата промяна.

**Защо този ред:**
- upgrade трябва да е готов ПРЕДИ да променяме шаблоните (иначе старите проекти няма да получат fix-а)
- .memory/ fix е малък и бърз — влиза веднага след upgrade
- ClientRequests е голям — ползва upgrade за да доставя новите правила

**Последствия:** v1.5.0 ще включва и трите: upgrade + .memory/ fix + ClientRequests.

---

### 2026-02-14 Пълно почистване и синхронизация на repo (v1.5.7)

**Контекст:** Одит показа, че GitHub repo съдържа: дублирани файлове (root .ts = src/), CargoFlow-специфични документи, PDF-и (6 MB), остарели версии в множество файлове. npm пакетът включва 4 излишни файла (71 kB). Нито един documents/ файл не се ползва от кода — всичко е inline в src/.

**Решение:**
1. **Изтрий от repo:** root cli.ts/memory.ts/modes.ts (дубликати на src/), Progres/ папка (лични бележки + PDF), documents/ PDF-и (6 MB), documents/setup_new_client.py (CargoFlow), documents/*.py (дублирани в templates/requests/python/)
2. **Премести в documents/archive/:** Svet AI Iron Rules.txt (стар бранд, първа версия), SVET_AI_FULL_DOCUMENTATION.md (v1.0.0, историческа), SVET_ECOSYSTEM_ROADMAP2.md (Draft v1.0), TIMELINE_AND_GAP_ANALYSIS.md (CargoFlow), README.md (CargoFlow ClientRequests), REGISTRY.md + TEMPLATE.md (дублирани в templates/requests/)
3. **Синхронизирай версии:** CLAUDE.md, .antigravity/rules.md, .cursorrules → v1.5.7; src/tools.ts header → v1.5.7; documents/IRON_RULES.md → v1.5.7; documents/USER_GUIDE.md → v1.5.7
4. **Обнови .npmignore:** documents/archive/, Progres/
5. **Обнови ARCHITECTURE.md** с реалната структура

**Алтернативи:** Изтриване на всички остарели файлове (отхвърлено — имат историческа стойност)
**Последствия:** Чисто repo, всички версии синхронизирани, npm пакетът е по-малък

---

### 2026-02-14 AI Office System — Визия и архитектура (OpenClaw + AI-Svetlio + GLM OCR)

**Контекст:** Jetson OCR pipeline доказа, че локалните модели работят production-ready (52 сек/стр, $0/мес). AI-Svetlio дава памет и правила, но работи само в IDE — непрограмистите не могат да го ползват. Планираният ASUS GX10 (128GB, 1000 TOPS) ще позволи 70B+ модели за цял офис. Липсва мостът между AI инструментите и хората, които не са технически.

**Решение: Мулти-агентна офис система**

1. **OpenClaw като интерфейс за хората** — WhatsApp, Telegram, WebChat. Непрограмистите пишат на нормален български, не виждат IDE/CLI/Docker.

2. **Отделни агенти с изолирани роли:**
   - "OCR Бот" — чете документи (снимка → текст)
   - "Офис Помощник" — общ чат, въпроси, справки
   - "Проект Мениджър" — статус на проекти, задачи, заявки

3. **AI-Svetlio като памет на системата** — .memory/ за всеки проект, Iron Rules за безопасност, .requests/ за клиентски заявки

4. **Модел за старт:** Anthropic Pro/Max (OAuth, фиксирана цена) или Gemini CLI / Claude CLI — за тестове. Локални модели на GX10 по-късно.

5. **Хостинг за старт:** Линукс виртуална машина (наличен ресурс)

6. **Фазирано изграждане** — от прост Telegram бот до пълна офис система

**Алтернативи:**
- Само WebChat интерфейс (отхвърлено — хората вече са в месинджърите)
- Само Claude Code/Cursor (отхвърлено — непрограмистите не могат)
- Готово SaaS решение (отхвърлено — искаме контрол, собствен хардуер, нулева цена)

**Последствия:**
- Нов проект: "AI Office System" (работно име)
- Зависимости: OpenClaw Gateway, AI-Svetlio, Jetson OCR, n8n
- Бъдеща зависимост: ASUS GX10 за локални LLM агенти
- Риск: Сложност на свързването; приемане от колегите

---

### 2026-02-19 Стратегия за миграция ai-svetlio → ai-svetlio-pro

**Контекст:** ai-svetlio-pro (v1.0.0) е наследник на ai-svetlio (v1.5.7), но колегите вече работят с оригинала на всяка машина. Трябва да решим как да преминем без да нарушим работата им.

**Решение: Фазиран подход — тествай сам, после разпространи**

1. **Фаза 1 (сега):** Двата пакета живеят заедно
   - Колегите: `ai-svetlio` → команда `svetlio` (v1.5.7) — без промяна
   - Аз: `ai-svetlio-pro` → команда `svetlio-pro` / `spro` (v1.0.0) — тестване
   - Няма конфликт — различни npm имена, различни CLI команди

2. **Фаза 2 (когато е готово):** Миграция
   - Добави `"svetlio"` alias в bin на ai-svetlio-pro
   - Колегите: `npm uninstall -g ai-svetlio && npm install -g ai-svetlio-pro`
   - Командата `svetlio` продължава да работи + получават sync

**Ключови факти:**
- Двата пакета са ОТДЕЛНИ npm пакети (различни имена, различни repos)
- `npm update ai-svetlio` НИКОГА няма да даде ai-svetlio-pro
- `.memory/` папките не зависят от кой пакет е инсталиран — данните са безопасни
- Не може просто да се ъпгрейдне — трябва деинсталация + нова инсталация

**Алтернативи:**
- Незабавна замяна за всички (отхвърлено — рисково без тестване)
- Паралелно съществуване завинаги (отхвърлено — svetlio-pro е наследник, не отделен продукт)

**Последствия:**
- Няма риск за колегите докато тествам
- При миграция трябва инструкция за всяка машина (uninstall + install)
- Трябва да се тества sync init/push/pull преди Фаза 2
